# JavaScript Callbacks â€“ Complete Reference Guide

This document explains **callbacks in JavaScript** using your exact examples.
It is written for:

- **Students** (clear fundamentals)
- **Working professionals** (real-world relevance)
- **Future reference** (best practices + evolution path)

---

## 1ï¸âƒ£ What is a Callback? (Core Idea)

> A **callback** is a function that is **passed as an argument** to another function and **executed later**.

### Why callbacks exist?

- JavaScript is **singleâ€‘threaded**
- Many operations are **event-based or async** (timers, APIs, file I/O)
- Callbacks allow **control, reuse, and flexibility**

---

## 2ï¸âƒ£ Example 1 â€“ Passing Function as Argument

### âœ… Code

```js
let sum = (a, b) => {
  console.log(a + b);
};

let sub = (a, b) => {
  console.log(a - b);
};

function cal(callback, a, b) {
  console.log("cal function calling");
  callback(a, b);
}

cal(sum, 10, 20);
```

### ðŸ–¥ Output

```
cal function calling
30
```

### ðŸ” Explanation

- `sum` is **not executed immediately**
- `sum` is **passed as data** to `cal`
- `cal` decides **when** and **how** to execute it

### ðŸŽ¯ Use Case

- Strategy pattern
- Plugâ€‘andâ€‘play business logic
- Reusable utilities

---

## 3ï¸âƒ£ Example 2 â€“ Inline Callback (Anonymous Function)

### âœ… Code

```js
function test(callback, a, b) {
  callback(10, 20);
}

test(
  (a, b) => {
    console.log(a + b);
  },
  10,
  20,
);
```

### ðŸ–¥ Output

```
30
```

### ðŸ” Explanation

- Callback is **defined at the call site**
- Useful for **one-time logic**

### ðŸŽ¯ Use Case

- Event handlers
- Array methods (`map`, `filter`, `reduce`)
- Quick transformations

---

## 4ï¸âƒ£ Example 3 â€“ Callback Returning Value

### âœ… Code

```js
function user(callback, a, b) {
  let sum = callback(a, b);
  console.log(sum);
  return true;
}

let status1 = user(
  (a, b) => {
    let c = a + b;
    return c;
  },
  10,
  20,
);

console.log(status1);
```

### ðŸ–¥ Output

```
30
true
```

### ðŸ” Explanation

- Callback **returns data** to parent function
- Parent function controls **flow + final result**

### ðŸŽ¯ Use Case

- Validation logic
- Calculation engines
- Plugin architectures

---

## 5ï¸âƒ£ Additional Advanced Callback Examples (Calculator & Design Patterns)

This section adds **new callback patterns** not covered above. These are extremely common in **real projects, interviews, and frameworks**.

---

### 5.1 Strategy Pattern â€“ Calculator Using Callbacks

#### âœ… Code

```js
let sum = (a, b) => a + b;
let sub = (a, b) => a - b;
let div = (a, b) => b / a;
let mul = (a, b) => a * b;

function calculator(funcName, a, b) {
  console.log("using two numbers");
  return funcName(a, b);
}

let result = calculator(sum, 10, 20);
console.log(result);

result = calculator(sub, 10, 20);
console.log(result);

result = calculator(div, 10, 20);
console.log(result);

result = calculator(mul, 10, 20);
console.log(result);
```

#### ðŸ–¥ Output

```
using two numbers
30
-10
2
200
```

#### ðŸ” Explanation

- `calculator` does **not know** what operation it performs
- Logic is injected at runtime
- This is called the **Strategy Pattern**

#### ðŸŽ¯ Real Use Case

- Payment gateways (different payment strategies)
- Discount engines
- Test execution engines (Playwright, Cypress hooks)

---

### 5.2 Callback with Named Functions (Readable & Debuggable)

#### âœ… Code

```js
let addition = function (a, b) {
  return a + b;
};

let division = function (a, b) {
  return b / a;
};

function performCalc(a, b, funcName1, funcName2) {
  console.log(funcName1(a, b));
  console.log(funcName2(a, b));
}

performCalc(10, 20, addition, division);
console.log("bye!!!!!!");
```

#### ðŸ–¥ Output

```
30
2
bye!!!!!!
```

#### ðŸ” Explanation

- Multiple callbacks can be passed
- Each callback has **single responsibility**

#### ðŸŽ¯ Best Use Case

- Validation + transformation pipelines
- Pre-step & post-step hooks

---

### 5.3 Callback Returning Value (Reusable Utility)

#### âœ… Code

```js
function summing(a, b) {
  return a + b;
}

function calc(funcName, a, b) {
  return funcName(a, b);
}

let t1 = calc(summing, 10, 30);
console.log(t1);
```

#### ðŸ–¥ Output

```
40
```

#### ðŸŽ¯ Why This Matters

- This is how **Array.map / reduce** work internally
- Clean separation of logic & execution

---

### 5.4 Framework-Style Callback Design (Very Important)

> Rule: **Never write callback body inside framework function**

#### âœ… Code

```js
function doSomething(funcName, url) {
  console.log("entering the url..." + url);
  funcName();
}

// caller
doSomething(() => {
  console.log("hello appp");
}, "http://www.google.com");
```

#### ðŸ–¥ Output

```
entering the url...http://www.google.com
hello appp
```

#### ðŸ” Explanation

- Framework controls flow
- User injects behavior

#### ðŸŽ¯ Real Use Case

- Express middleware
- Playwright hooks (beforeEach)
- Plugin systems

---

### 5.5 Modern Arrow Callback Injection

#### âœ… Code

```js
const performOperation = (a, b, operation) => {
  return operation(a, b);
};

const result1 = performOperation(4, 2, (x, y) => x * y);
console.log(result1);
```

#### ðŸ–¥ Output

```
8
```

## 6ï¸âƒ£ Example 4 â€“ Realâ€‘World Async Callback (Coffee Machine)

### âœ… Code

```js
function startMachin(callback) {
  setTimeout(() => {
    console.log("1. Start Machin");
    callback();
  }, 5000);
}

function bilwater(callback) {
  setTimeout(() => {
    console.log("2. bil water");
    callback();
  }, 3000);
}

function addCoffeePowder(callback) {
  setTimeout(() => {
    console.log("3. add Coffee Powder");
    callback();
  }, 4000);
}

function popinCup(callback) {
  setTimeout(() => {
    console.log("4. pop in Cup");
    callback();
  }, 3000);
}

function servecofee(callback) {
  setTimeout(() => {
    console.log("5. serve cofee");
    callback();
  }, 1000);
}

startMachin(() => {
  bilwater(() => {
    addCoffeePowder(() => {
      popinCup(() => {
        servecofee(() => {
          console.log("done");
        });
      });
    });
  });
});
```

### ðŸ–¥ Output (Time-based)

```
1. Start Machin
2. bil water
3. add Coffee Powder
4. pop in Cup
5. serve cofee
done
```

### ðŸ” Explanation

- Each step **waits for previous step**
- Execution order is guaranteed
- This is **callback chaining**

---

## âš ï¸ Callback Hell (Problem)

```js
start(() => {
  step1(() => {
    step2(() => {
      step3(() => {
        step4(() => {});
      });
    });
  });
});
```

### Problems

- Hard to read
- Hard to debug
- Hard to scale

---

## âœ… Best Practices (VERY IMPORTANT)

### âœ” Use callbacks when:

- Small logic
- Event handling
- Library hooks

### âŒ Avoid callbacks when:

- Multiple async steps
- Business workflows

### âœ” Prefer:

- `Promise`
- `async / await`

### âœ” Always:

- Name callbacks clearly
- Handle errors
- Keep callbacks **small**

---

## ðŸ” Modern Replacement (Recommended)

### Same Coffee Example (Cleaner)

```js
async function makeCoffee() {
  await startMachin();
  await bilwater();
  await addCoffeePowder();
  await popinCup();
  await servecofee();
  console.log("done");
}
```

---

## ðŸ§  My Professional Thoughts

- Callbacks are **foundation**, not final destination
- Every JS developer **must master callbacks**
- Real-world systems use:
  - Promises
  - async/await
  - Event-driven patterns

> ðŸ’¡ **If callbacks are not clear, Promises will never be clear.**

---

## ðŸ“Œ Summary Table

| Topic           | Why It Matters     |
| --------------- | ------------------ |
| Callback basics | Core JS concept    |
| Async flow      | JS execution model |
| Callback hell   | Design smell       |
| Promises        | Maintainable async |
| async/await     | Industry standard  |

---

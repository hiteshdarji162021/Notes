# What covered in notes
- Scrolling
- Screenshort and its options
- MutiwindowHandle using waitforevent

## 1. Page Scrolling Techniques

### 1.1 Normal Scroll using JavaScript

**Concept**  
Manually scroll the page using browser JavaScript APIs.

**When to use**  
- Simple static pages
- When Playwright auto-scroll doesn’t trigger

**Code**
```ts
await page.evaluate(() => window.scrollBy(0, 1000));
await page.waitForTimeout(2000);
```

**Output**  
Page scrolls down by 1000px.

**Notes**  
- Fast but not user-like
- May fail for lazy loading websites

---

### 1.2 Scroll to Bottom / Top

**Code**
```ts
await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
await page.waitForTimeout(2000);

await page.evaluate(() => window.scrollTo(0, 0));
```

**Use case**  
- Reach footer
- Reset page scroll

---

### 1.3 Scroll Element into View (BEST PRACTICE)

**Concept**  
Scroll only until a particular element becomes visible.

**Code**
```ts
const career = page.locator("a[href*='company/careers'][target='_blank']");
await career.scrollIntoViewIfNeeded();
await career.click();
```

**Why best**  
- Safe
- No hardcoded scroll values
- Playwright-managed

---

## 2. Lazy Loading Scroll (Amazon / Infinite Scroll)

### Concept
Content loads **only when user scrolls**.

**Correct Pattern**
```ts
const section = page.getByText('Inspired by your browsing history');

while (!await section.isVisible()) {
  await page.mouse.wheel(0, 500);
  await page.waitForTimeout(2000);
}

console.log(await section.textContent());
```

**Output**  
Section text prints once it appears.

**Important Notes**  
- Use `mouse.wheel()` for user‑like scrolling
- Avoid `scrollTo(bottom)` for lazy sites

---

## 3. Screenshot Handling (Page & Element)

### 3.1 Full Page & Viewport Screenshot

**Code**
```ts
await page.screenshot({ path: 'one.png' });
await page.screenshot({ path: 'full.png', fullPage: true });
```

**Output**  
PNG images saved to project folder.

---

### 3.2 Screenshot with Clip Area

```ts
await page.screenshot({
  path: 'clip.png',
  clip: { x: 0, y: 0, width: 800, height: 600 }
});
```

---

### 3.3 Element Screenshot

```ts
const logo = page.locator('img[alt="OrangeHRM Logo"]').first();
await logo.screenshot({ path: 'logo.png' });
```

---

### 3.4 JPEG & Quality Control

```ts
await page.screenshot({
  path: 'page.jpg',
  type: 'jpeg',
  quality: 30
});
```

---

### 3.5 Screenshot as Buffer

```ts
const buffer = await page.screenshot();
console.log(buffer.length);
```

**Use case**  
- Attach to report
- Upload to server

---

## 4. Multi‑Window / Popup Handling (Event Listener)

### Concept
New tab opens → Playwright treats it as **popup event**.

###  special note:
- dont use await in Promise.all - because if any of the promises is fulfilled, it will be retunred immedialtely.
- Dont change the sequence also - first wait for the event, then trigger the event by clicking on it.
- dont use await page.locator().click() then await page.waitForEvent() - it will be running in the sequential mode.
- after click() - promise is fulfilled and it will be returned - it wont capture the event.
- so always use without await here with the same sequence:1st wait for the popup event. 2nd perform click on the element.
- Here [nePage] is array distructuring. because promise.all return all. first waitforevent return page and second retun void as click.
-  we skip void and only use page things so we written [newPage[] as array distructring and return array.

```ts
const [newPage] = await Promise.all([
  page.waitForEvent('popup'),
  page.locator("//a[contains(@href,'linkedin')]").click()
]);

console.log(await newPage.title());
console.log(newPage.url());
await newPage.close();
```

**Why Promise.all?**  
- Prevents race condition
- Listener starts BEFORE click

**Notes**  
- `[newPage]` = array destructuring
- `click()` returns Promise<void>

---

### Bring Parent Page Back

```ts
await page.bringToFront();
console.log(await page.title());
```

---

## 5. Dialog / Alert Handling

### 5.1 Default Playwright Behavior

**Fact**  
If you DO NOTHING → Playwright auto‑dismisses alerts.

---

### 5.2 Custom Dialog Handler

```ts
page.on('dialog', async (dialog: Dialog) => {
  console.log(dialog.message());
  await dialog.accept();
});
```

**Use when**  
- Need to validate alert text
- Need to accept / dismiss manually

---

### 5.3 Remove Custom Handler (Back to Default)

```ts
page.off('dialog', handler);
```

**Result**  
Playwright resumes auto‑dismiss behavior.

---

## 6. Cookie Popup Handling using Event Listener

### `framenavigated` is a **Playwright page-level event** that fires **every time any frame navigates**.

This includes:
- Main page navigation
- Iframe navigation
- Reloads
- Redirects

```ts
page.on('framenavigated', async () => {
  // code executed when navigation happens
});
```

---

### Why Use `framenavigated` for Cookie Popups?

### Problem
Cookie banners:
- Appear **unexpectedly**
- May appear **after page load**
- May reload inside **iframe**
- Block user actions

Traditional code like this may fail:
```ts
await page.getByText('Allow all').click(); // ❌ may not exist yet
```

---

### Solution
Use an **event listener** that keeps listening in the background and clicks the button **whenever it appears**.

```ts
page.on('framenavigated', async () => {
  await page.getByText('Allow all').click();
});
```

This makes your test **self-healing** for cookie popups.

---

### When Exactly Does `framenavigated` Trigger?

`framenavigated` triggers when:
- Page loads for the first time
- Page redirects
- Any iframe loads or refreshes

So it is ideal for:
- Cookie banners
- GDPR consent popups
- Region / language popups
- Marketing banners loaded via iframe

---

### Use Cases (Very Important)

### ✔ Recommended Use Cases

- Cookie consent banners (Accept / Allow All)
- GDPR popups
- Iframe-based popups
- Popups that appear at **any unpredictable time**

### ❌ Not Recommended Use Cases

- Business logic
- Assertions
- Form filling
- Navigation logic

---

### Full Working Example

```ts
import { chromium } from '@playwright/test';

(async () => {
  const browser = await chromium.launch({ headless: false });
  const page = await browser.newPage();

  // Background listener for cookie popup
  page.on('framenavigated', async () => {
    const allowBtn = page.getByText('Allow all');
    if (await allowBtn.isVisible()) {
      await allowBtn.click();
    }
  });

  await page.goto('https://www.orangehrm.com/en/contact-sales/');
})();
```

---

### Output / Result

- Page loads normally
- Cookie banner is auto-accepted
- Test does not fail due to popup
- No manual waits required

---

### Important Notes (MUST READ)

### ⚠ Avoid Heavy Logic Inside Listener

❌ BAD PRACTICE
```ts
page.on('framenavigated', async () => {
  await page.waitForTimeout(5000);
  await page.fill('#email', 'test@test.com');
});
```

✔ GOOD PRACTICE
```ts
page.on('framenavigated', async () => {
  const allowBtn = page.getByText('Allow all');
  if (await allowBtn.isVisible()) {
    await allowBtn.click();
  }
});
```

Reason:
- Event fires multiple times
- Heavy logic causes flaky tests
- May slow down execution

---

### Does `framenavigated` Work Without Frames?

✅ YES

Even if the page has **no iframe**, `framenavigated` still works because:
- The main page itself is a frame

So this listener works for:
- Normal DOM elements
- Iframe elements
- Mixed content pages

---

### Difference Between Default Handling vs Event Listener

| Approach | Behavior |
|------|------|
| Normal click | One-time, may fail |
| `framenavigated` listener | Background, auto-handles |
| No handler | Popup blocks test |

---

### Best Practice Summary (For Students)

- Use `framenavigated` for unpredictable popups
- Keep listener logic very light
- Use visibility checks
- Avoid waits inside listeners
- Remove listener if no longer needed

---

### Interview One-Liner

> `framenavigated` is used as a background listener to handle unpredictable UI events like cookie banners that may appear during navigation or iframe loads.

---

### Best Practice Summary (For Students)

- Prefer `scrollIntoViewIfNeeded()` over JS scroll
- Lazy loading ≠ normal scrolling
- Always listen before triggering popup
- Promise.all returns ARRAY
- Alerts auto‑dismiss unless handled
- Element screenshots > full page when validating UI

---

### Interview Ready One‑Liners

- Lazy loading works only when you trigger the correct scroll mechanism
- Promise.all prevents missing popup events
- Playwright auto‑dismisses dialogs by default
- Element scrolling is safer than page scrolling

---

## End of Canvas


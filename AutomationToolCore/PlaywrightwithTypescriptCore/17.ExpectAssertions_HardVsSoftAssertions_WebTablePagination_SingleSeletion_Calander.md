This canvas explains **theory first**, then **code**, **output**, **use cases**, **best practices**, and **future-ready variations** for:
1. Assertions in Playwright
2. Web table pagination (single & multiple selection)
3. Calendar date selection

---

## 1️⃣ Playwright Assertions – Theory

### What is an Assertion?
An assertion verifies that the **actual result** matches the **expected result**. If it fails, the test fails.

### Why Assertions Matter
- Validate application behavior
- Catch UI regressions early
- Act as documentation for test intent

Playwright assertions are **auto-waiting**, meaning they retry until timeout.

---

## 1.1 Value Assertions (Non-UI)

### Use Case
- Unit-style validation
- Business logic checks
- API or utility validation

### Code
```ts
import { test, expect } from '@playwright/test';

test('value assertions', async () => {
  expect(1 + 1).toBe(2);
  expect('playwright').toContain('play');
  expect([1, 2, 3]).toEqual([1, 2, 3]);
  expect(true).toBeTruthy();
  expect(false).toBeFalsy();
  expect(null).toBeNull();
  expect(50).toBeGreaterThan(10);
  expect({ role: 'admin' }).toEqual({ role: 'admin' });
  expect({ age: 20, role: 'admin' }).toEqual({ role: 'admin', age: 20 });
});
```

### Output
- All checks pass → test ✅
- Any mismatch → test ❌

### Best Practice
Use value assertions for **logic**, not UI.

---

## 1.2 Locator-Based Assertions

### Theory
Used to validate **UI elements** (text, visibility, CSS, attributes).

### Use Case
- Validate page content
- Ensure elements are visible/enabled

### Code
```ts
test('locator based assertions', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');

  const header = page.getByText('Returning Customer', { exact: true });
  await expect(header).toBeVisible();
  await expect(header).toHaveText('Returning Customer');
  await expect(header).toContainText('Returning');

  const emailId = page.getByRole('textbox', { name: 'E-Mail Address' });
  await expect(emailId).toHaveAttribute('id', 'input-email');
  await expect(emailId).toHaveCSS('height', '34px');

  const footerLinks = page.locator('//footer//a');
  await expect(footerLinks).toHaveCount(16);
});
```

### Best Practice
Prefer `getByRole`, `getByText` over XPath when possible.

---

## 1.3 Soft Assertions

### Theory
Soft assertions **do not stop execution** on failure.

### Use Case
- Collect multiple UI issues in one run
- Reporting-focused tests

### Code
```ts
test('soft assertions', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');

  const header = page.getByText('Returning Customer', { exact: true });

  await expect.soft(header).toHaveText('Returning ');
  await expect.soft(header).toHaveText('Customer');

  console.log('Done!!');
});
```

---

## 1.4 NOT Assertions

### Theory
Validates **absence** of element or value.

### Code
```ts
test('not assertions', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');

  await expect(page.locator('#error')).not.toBeVisible();
  const title = await page.title();
  expect(title).not.toContain('error');
});
```

---

## 1.5 Screenshot Assertions

### Theory
Compares UI visually (pixel comparison).

### Use Case
- UI regression testing
- Layout verification

### Code
```ts
test('screenshot assertions', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  const header = page.getByText('Returning Customer', { exact: true });
  await expect(header).toHaveScreenshot('header.png');
});
```

---

## 1.6 URL & Title Assertions

### Code
```ts
test('url and title assertions', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');

  await expect(page).toHaveTitle('Account Login');
  await expect(page).toHaveURL(/.*account\/login.*/);

  const appUrl = page.url();
  expect(appUrl).toContain('account/login');
});
```

---

## 1.7 Visible / Enabled / Disabled Assertions

### Use Case
Forms and validation flows.

### Code
```ts
test('element state assertions', async ({ page }) => {
  await page.goto('https://classic.freecrm.com/register/');

  const checkbox = page.getByLabel('I agree with the terms and conditions.');
  const submitBtn = page.getByRole('button', { name: 'SUBMIT' });

  await expect(checkbox).not.toBeChecked();
  await expect(submitBtn).toBeDisabled();

  await checkbox.check();

  await expect(checkbox).toBeChecked();
  await expect(submitBtn).toBeEnabled();
});
```

---

# 2️⃣ Web Table Pagination

## 2.1 Single Selection

### Theory
Navigate pages until a row is found, then act.

### Code
```ts
test('single selection', async ({ page }) => {
  await page.goto('https://selectorshub.com/xpath-practice-page/');

  while (true) {
    const isExist = await page.locator("//td[text()='Hong Kong']").isVisible();
    if (isExist) {
      await page.locator("//td[text()='Hong Kong']/preceding-sibling::td/input").check();
      break;
    }

    const next = page.getByRole('link', { name: 'Next' });
    if (await next.isDisabled()) break;
    await next.click();
  }
});
```

### Use Case
- CRM tables
- Admin dashboards

---

## 2.2 Multiple Selection

### Theory
Select matching rows across all pages.

### Code
```ts
test('multiple selection', async ({ page }) => {
  await page.goto('https://selectorshub.com/xpath-practice-page/');

  while (true) {
    const rows = await page.locator("//td[text()='India']/preceding-sibling::td/input").all();
    for (const r of rows) await r.click();

    const next = page.getByRole('link', { name: 'Next' });
    if (await next.isDisabled()) break;
    await next.click();
  }
});
```

---

# 3️⃣ Calendar Handling

## Theory
Calendars are **dynamic UI widgets**. You must:
- Read current month
- Compare with expected
- Navigate until match

---

## Code (Readable & Maintainable)

```ts
test('calendar single selection', async ({ page }) => {
  await page.goto('https://seleniumpractise.blogspot.com/2016/08/how-to-handle-calendar-in-selenium.html');
  await page.locator('#datepicker').click();

  const expectedMonthYear = 'April 2026';

  const normalize = (text?: string) =>
    text?.trim().split(' ').filter(Boolean).join(' ');

  while (true) {
    const currentMonthYear = await page.locator('div.ui-datepicker-title').innerText();

    if (normalize(currentMonthYear) === normalize(expectedMonthYear)) {
      await page.getByText('16', { exact: true }).click();
      break;
    }

    await page.locator('span:has-text("Next")').click();
  }
});
```

---

## Best Practices Summary
- Prefer `innerText()` over `textContent()`
- Avoid regex inside conditions
- Extract logic into helper functions
- Always guard infinite loops

---

## Future Use Cases
- Date range picker
- Multi-calendar widgets
- Localization (Jan / Januar / Enero)
- Reusable calendar utility

---

## Interview One-Liner
> I design Playwright tests with readable assertions, reusable helpers, and safe pagination logic to keep tests stable and maintainable.

---
## 1ï¸âƒ£ Core Theory â€“ Why These Features Exist

Modern test frameworks must support:
- Fast local debugging
- Clear communication of test intent
- Stable CI execution
- Known failures without breaking pipelines

Playwright provides **test annotations and controls** to handle all of this cleanly.

---

## 2ï¸âƒ£ Basic Assertions with Annotations

### Theory
Assertions validate expected behavior. Annotations change **how and when** tests run.

### Code
```ts
import { test, expect } from '@playwright/test';

test('title test', async ({ page, browserName }) => {
  // test.skip(browserName === 'firefox', 'Feature not supported in Firefox');
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await expect(page).toHaveTitle('Account Login1', { timeout: 50000 });
});
```

### Output Behavior
- Runs normally
- Fails if title does not match

### Use Case
- Learning failure reporting
- Title regression checks

---

## 3ï¸âƒ£ Running a Single Test using `test.only`

### Theory
`test.only` runs **only that test** and skips all others.

### Code
```ts
test.only('url test', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await expect(page).toHaveURL(/.*account\/login.*/);
});
```

### Output
- Only this test executes

### Best Practice
Remove `test.only` before committing or running CI.

---

## 4ï¸âƒ£ Skipping Tests using `test.skip`

### Theory
Marks a test as intentionally not executed.

### Code
```ts
test.skip('header is visible', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await expect(page.getByText('Returning Customer', { exact: true })).toBeVisible();
});
```

### Use Case
- Feature not ready
- Blocked by dependency

---

## 5ï¸âƒ£ Marking Slow Tests using `test.slow`

### Theory
Extends timeout for slower environments.

### Code
```ts
test('emailid is visible', async ({ page, browserName }) => {
  test.slow(browserName === 'firefox', 'Slow in Firefox');
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await expect(page.getByRole('textbox', { name: 'E-Mail Address' })).toBeVisible();
});
```

### Use Case
- Cross-browser differences
- CI performance variance

---

## 6ï¸âƒ£ Known Issues using `test.fixme`

### Theory
Signals a test that is expected to fail and needs fixing.

### Code
```ts
test.fixme('password is visible', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await expect(page.getByRole('textbox', { name: 'Password' })).toBeVisible();
});
```

### Best Practice
Use instead of deleting failing tests.

---

## 7ï¸âƒ£ Expected Failures using `test.fail`

### Theory
Test is expected to fail but still executes.

### Code
```ts
test('new customer header is visible', async ({ page }) => {
  test.fail();
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await expect(page.getByText('New Customer11', { exact: true })).toBeVisible();
});
```

### Output
- Failure treated as expected

---

## 8ï¸âƒ£ Step-wise Execution using `test.step`

### Theory
Breaks a test into logical steps visible in reports.

### Code
```ts
test('password ele is visible', async ({ page }) => {
  test.step('go to page url', async () => {
    await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  });

  test.step('check password element', async () => {
    await expect(page.getByRole('textbox', { name: 'Password' })).toBeVisible();
  });
});
```

### Use Case
- Debugging
- Better HTML reports

---

## 9ï¸âƒ£ Grouping Tests using `test.describe`

### Theory
Logical grouping for readability and shared hooks.

### Code
```ts
test.describe('basic test suite', () => {
  test('title test', async ({ page }) => { /* ... */ });
  test('url test', async ({ page }) => { /* ... */ });
  test('header is visible', async ({ page }) => { /* ... */ });
});

test.describe('advance test suite', () => {
  test('emailid is visible', async ({ page }) => { /* ... */ });
  test('password is visible', async ({ page }) => { /* ... */ });
  test('new customer header is visible', async ({ page }) => { /* ... */ });
});
```

### Output
- Clean grouped reports

---

## ðŸ”Ÿ Hooks, Fixtures, Tags & Retries (Conceptual)

### Hooks
- `beforeEach`, `afterEach`
- Shared setup/cleanup

### Fixtures
- Inject reusable logic (login, API context)

### Tags
- `@smoke`, `@regression`
- Filter runs via CLI

### Retries
- Useful in CI
- Example concept:
```ts
retries: process.env.CI ? 2 : 2
```

---

## 1ï¸âƒ£1ï¸âƒ£ Best Practices Summary

- Avoid committing `test.only`
- Prefer `fixme` over deleting tests
- Use `fail` for known, verified failures
- Group tests early using `describe`
- Use `step` for long workflows

---

## 1ï¸âƒ£2ï¸âƒ£ Future-Ready Use Cases

- CI/CD pipelines
- Multi-browser execution
- Flaky test control
- Teaching & documentation
- Framework-level standards

---

## Interview One-Liner
> Playwright annotations allow fine-grained control over test execution, making suites stable, readable, and CI-friendly while clearly communicating intent.

---
# What covered in notes
-  **Hooks**
-  **Serial execution**
-  **Parameterization**, 
-  **DataProvider patterns** 

---

## 1ï¸âƒ£ Global Hooks (beforeAll, beforeEach, afterEach, afterAll)

### ğŸ”¹ Code Example
```ts
import { test, expect } from '@playwright/test';

test.beforeAll(async () => {
  console.log('called before all');
});

test.beforeEach(async () => {
  console.log('before each');
});

test.afterEach(async () => {
  console.log('after each');
});

test('actual test1', async () => {
  console.log('actual test1');
});

test('actual test2', async () => {
  console.log('actual test2');
});

test.afterAll(async () => {
  console.log('called after all');
});
```

### ğŸ”¹ Execution Order
```
beforeAll
  beforeEach â†’ test1 â†’ afterEach
  beforeEach â†’ test2 â†’ afterEach
afterAll
```

### âœ… Use When
- DB setup / token generation
- Browser or environment initialization

---

## 2ï¸âƒ£ Hooks Inside test.describe (Scoped Hooks)

### ğŸ”¹ Code Example
```ts
test.describe('group 1', () => {

  test.beforeAll(async () => {
    console.log('group before all');
  });

  test.beforeEach(async () => {
    console.log('group before each');
  });

  test('test 1', async () => {
    console.log('test 1');
  });

  test('test 2', async () => {
    console.log('test 2');
  });

  test.afterAll(async () => {
    console.log('group after all');
  });
});
```

### ğŸ”¹ Key Point
- Hooks apply **only to tests inside describe**
- Clean & modular test design

---

## 3ï¸âƒ£ Serial Execution (test.describe.serial)

### ğŸ”¹ Code Example
```ts
test.describe.serial('serial group', () => {

  test('test 1', async () => {
    console.log('test 1');
  });

  test('test 2 - fail', async () => {
    console.log('test 2');
    expect(true).toBe(false);
  });

  test('test 3', async () => {
    console.log('test 3');
  });
});
```

### ğŸ”¹ Behavior
- If **any test fails**, remaining tests are **skipped**
- If retry is their for e.g 2 time retries for fail test in that case if 2nd test fail then 1st and 2nd both run again.

### âœ… Use When
- Dependent workflows (checkout, multi-step flows)

---

## 4ï¸âƒ£ UI Tests Using Hooks with Page Fixture

### ğŸ”¹ Code Example
```ts
test.describe('login page tests', () => {

  test.beforeEach(async ({ page }) => {
    await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  });

  test('title validation', async ({ page }) => {
    await expect(page).toHaveTitle('Account Login');
  });

  test('header validation', async ({ page }) => {
    await expect(page.getByText('Returning Customer', { exact: true })).toBeVisible();
  });

  test.afterEach(async ({ page }) => {
    await page.close();
  });
});
```

### âœ… Best Practice
- Put **navigation in beforeEach**
- Keep tests clean and readable

---

## 5ï¸âƒ£ Data-Driven Testing Using Array (DataProvider)

### ğŸ”¹ Code Example
```ts
const loginData = [
  { username: 'user1@gmail.com', password: 'pass1' },
  { username: 'user2@gmail.com', password: 'pass2' }
];

for (const data of loginData) {
  test(`login test for ${data.username}`, async ({ page }) => {
    await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
    await page.fill('#input-email', data.username);
    await page.fill('#input-password', data.password);
    await page.click('input[value="Login"]');
  });
}
```

### âœ… Pros
- Simple
- No external dependency

### âŒ Cons
- Not scalable for large data

---

## 6ï¸âƒ£ Data-Driven Testing Using JSON (Two Approaches)

### ğŸ“ JSON File (regdata.json)
```json
[
  {
    "firstName": "hitesh",
    "lastname": "darji",
    "telephone": "9876543210",
    "password": "9925472398@hH",
    "subscription": "Yes"
  }
]
```

---

### âœ… Approach 1: Direct JSON Import (BEST & RECOMMENDED)
```ts
import registrationData from '../regdata.json' assert { type: 'json' };

for (const user of registrationData) {
  test(`registration ${user.firstName}`, async ({ page }) => {
    await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/register');
    await page.fill('#input-firstname', user.firstName);
    await page.fill('#input-lastname', user.lastname);
  });
}
```

### â­ Why Best?
- Clean
- Type-safe
- No fs required
- Works perfectly with Playwright + TS

---

### âš ï¸ Approach 2: fs + JSON.parse (ADVANCED / NOT NEEDED)
```ts
import fs from 'fs';

type RegData = {
  firstName: string;
  lastname: string;
  telephone: string;
  password: string;
  subscription: string;
};

const registrationData: RegData[] = JSON.parse(
  fs.readFileSync('./regdata.json', 'utf-8')
);
```

### âŒ Drawbacks
- Extra boilerplate
- Sync file read
- Not Playwright-native

---

## 7ï¸âƒ£ Best Practice Summary Table

| Feature         | Best Choice           |
| --------------- | --------------------- |
| Hooks           | Scoped describe hooks |
| Dependent tests | describe.serial       |
| Small data      | Array loop            |
| Large data      | JSON import           |
| Maintainability | JSON + import         |
| Speed           | Avoid fs.readFileSync |

---

## 8ï¸âƒ£ Interview-Ready One-Liners

- **beforeAll** runs once per file
- **beforeEach** runs before every test
- **serial** stops execution on failure
- **JSON import** is best for data-driven testing
- **Avoid fs** unless dynamic runtime data is required

---

## Import differnt types 

### 1ï¸âƒ£ Named Imports ( `{ }` REQUIRED )

### ğŸ“Œ When to use
- Module exports **multiple named members**
- You want **specific utilities** from a module

### ğŸ”¹ Example: Playwright
```ts
import { test, expect } from '@playwright/test';
```

### ğŸ”¹ Internal Export (conceptual)
```ts
export const test = ...
export const expect = ...
export const chromium = ...
```

### ğŸ”¹ Rules
- `{ }` is **MANDATORY**
- Names are **FIXED** (must match export)
- You may rename using `as`

```ts
import { test as pwTest, expect as pwExpect } from '@playwright/test';
```

### âŒ Invalid
```ts
import test from '@playwright/test';
```

### ğŸ§  Key Takeaway
> Named exports â†’ `{}` required â†’ names are fixed unless aliased

---

### 2ï¸âƒ£ Default Import ( `{ }` NOT used )

### ğŸ“Œ When to use
- Module exports **one main value**
- Common in Node.js & JSON

### ğŸ”¹ Example: fs
```ts
import fs from 'fs';
```

### ğŸ”¹ Example: JSON
```ts
import registrationData from '../regdata.json' assert { type: 'json' };
```

### ğŸ”¹ Rules
- `{ }` âŒ NOT used
- Import name is **COMPLETELY FLEXIBLE**
- Only **ONE default export** exists

```ts
import abc from 'fs';
import fileSystem from 'fs';
import data from '../regdata.json';
```

All are âœ… valid.

### âŒ Invalid
```ts
import { fs } from 'fs';
import { data } from '../regdata.json';
```

### ğŸ§  Key Takeaway
> Default export â†’ no `{}` â†’ name can be anything

---

### 3ï¸âƒ£ Mixed Import ( Default + Named )

### ğŸ“Œ When to use
- Module exports **one default AND multiple named exports**

### ğŸ”¹ Export Example
```ts
export default function logger() {}
export const info = () => {}
export const error = () => {}
```

### ğŸ”¹ Import Syntax
```ts
import logger, { info, error } from './logger';
```

### ğŸ”¹ Rules
- Default import name â†’ flexible
- Named imports â†’ fixed (or aliased)

```ts
import myLogger, { info as logInfo } from './logger';
```

### ğŸ§  Key Takeaway
> Default + named â†’ both syntaxes together

---

### 4ï¸âƒ£ Name Flexibility Summary (VERY IMPORTANT)

| Import Type | `{ }` | Name Flexible? | Example |
|-----------|------|---------------|--------|
| Named | âœ… Required | âŒ Fixed | `{ test, expect }` |
| Default | âŒ Not used | âœ… Any name | `fs`, `abc`, `data` |
| Mixed | Both | Default âœ… / Named âŒ | `logger, { info }` |

---

### 5ï¸âƒ£ Real Playwright Examples (Correct Usage)

### âœ… Playwright
```ts
import { test, expect } from '@playwright/test';
```

### âœ… JSON Data Provider (BEST)
```ts
import users from '../regdata.json' assert { type: 'json' };
```

### âœ… fs (if really needed)
```ts
import fs from 'fs';
fs.readFileSync(...);
```

---

### 6ï¸âƒ£ Common Interview Traps âŒ

```ts
import fs from '@playwright/test';   // âŒ
import { test } from 'fs';            // âŒ
import { data } from './data.json';   // âŒ
```

---

### 7ï¸âƒ£ One-Line Interview Answers

- **Named exports** require `{ }`
- **Default exports** never use `{ }`
- **JSON always has default export**
- **Alias does not change API**

---

## âœ… Final Golden Rule (Pin This)

> ğŸ‘‰Curly braces are required only for named exports.**
> ğŸ‘‰ Default exports allow any variable name.**
> ğŸ‘‰ Use **describe + hooks + JSON import** for enterprise-grade Playwright frameworks.
> ğŸ‘‰ This structure is **scalable, readable, fast, and interview-safe**.

-----
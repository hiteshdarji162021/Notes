# What covered in notes
-  **Hooks**
-  **Serial execution**
-  **Parameterization**, 
-  **DataProvider patterns** 

---

## 1Ô∏è‚É£ Global Hooks (beforeAll, beforeEach, afterEach, afterAll)

### üîπ Code Example
```ts
import { test, expect } from '@playwright/test';

test.beforeAll(async () => {
  console.log('called before all');
});

test.beforeEach(async () => {
  console.log('before each');
});

test.afterEach(async () => {
  console.log('after each');
});

test('actual test1', async () => {
  console.log('actual test1');
});

test('actual test2', async () => {
  console.log('actual test2');
});

test.afterAll(async () => {
  console.log('called after all');
});
```

### üîπ Execution Order
```
beforeAll
  beforeEach ‚Üí test1 ‚Üí afterEach
  beforeEach ‚Üí test2 ‚Üí afterEach
afterAll
```

### ‚úÖ Use When
- DB setup / token generation
- Browser or environment initialization

---

## 2Ô∏è‚É£ Hooks Inside test.describe (Scoped Hooks)

### üîπ Code Example
```ts
test.describe('group 1', () => {

  test.beforeAll(async () => {
    console.log('group before all');
  });

  test.beforeEach(async () => {
    console.log('group before each');
  });

  test('test 1', async () => {
    console.log('test 1');
  });

  test('test 2', async () => {
    console.log('test 2');
  });

  test.afterAll(async () => {
    console.log('group after all');
  });
});
```

### üîπ Key Point
- Hooks apply **only to tests inside describe**
- Clean & modular test design

---

## 3Ô∏è‚É£ Serial Execution (test.describe.serial)

### üîπ Code Example
```ts
test.describe.serial('serial group', () => {

  test('test 1', async () => {
    console.log('test 1');
  });

  test('test 2 - fail', async () => {
    console.log('test 2');
    expect(true).toBe(false);
  });

  test('test 3', async () => {
    console.log('test 3');
  });
});
```

### üîπ Behavior
- If **any test fails**, remaining tests are **skipped**
- If retry is their for e.g 2 time retries for fail test in that case if 2nd test fail then 1st and 2nd both run again.

### ‚úÖ Use When
- Dependent workflows (checkout, multi-step flows)

---

## 4Ô∏è‚É£ UI Tests Using Hooks with Page Fixture

### üîπ Code Example
```ts
test.describe('login page tests', () => {

  test.beforeEach(async ({ page }) => {
    await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  });

  test('title validation', async ({ page }) => {
    await expect(page).toHaveTitle('Account Login');
  });

  test('header validation', async ({ page }) => {
    await expect(page.getByText('Returning Customer', { exact: true })).toBeVisible();
  });

  test.afterEach(async ({ page }) => {
    await page.close();
  });
});
```

### ‚úÖ Best Practice
- Put **navigation in beforeEach**
- Keep tests clean and readable

---

## 5Ô∏è‚É£ Data-Driven Testing Using Array (DataProvider)

### üîπ Code Example
```ts
const loginData = [
  { username: 'user1@gmail.com', password: 'pass1' },
  { username: 'user2@gmail.com', password: 'pass2' }
];

for (const data of loginData) {
  test(`login test for ${data.username}`, async ({ page }) => {
    await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
    await page.fill('#input-email', data.username);
    await page.fill('#input-password', data.password);
    await page.click('input[value="Login"]');
  });
}
```

### ‚úÖ Pros
- Simple
- No external dependency

### ‚ùå Cons
- Not scalable for large data

---

## 6Ô∏è‚É£ Data-Driven Testing Using JSON (Two Approaches)

### üìÅ JSON File (regdata.json)
```json
[
  {
    "firstName": "hitesh",
    "lastname": "darji",
    "telephone": "9876543210",
    "password": "9925472398@hH",
    "subscription": "Yes"
  }
]
```

---

### ‚úÖ Approach 1: Direct JSON Import (BEST & RECOMMENDED)
```ts
import registrationData from '../regdata.json' assert { type: 'json' };

for (const user of registrationData) {
  test(`registration ${user.firstName}`, async ({ page }) => {
    await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/register');
    await page.fill('#input-firstname', user.firstName);
    await page.fill('#input-lastname', user.lastname);
  });
}
```

### ‚≠ê Why Best?
- Clean
- Type-safe
- No fs required
- Works perfectly with Playwright + TS

---

### ‚ö†Ô∏è Approach 2: fs + JSON.parse (ADVANCED / NOT NEEDED)
```ts
import fs from 'fs';

type RegData = {
  firstName: string;
  lastname: string;
  telephone: string;
  password: string;
  subscription: string;
};

const registrationData: RegData[] = JSON.parse(
  fs.readFileSync('./regdata.json', 'utf-8')
);
```

### ‚ùå Drawbacks
- Extra boilerplate
- Sync file read
- Not Playwright-native

---

## 7Ô∏è‚É£ Best Practice Summary Table

| Feature         | Best Choice           |
| --------------- | --------------------- |
| Hooks           | Scoped describe hooks |
| Dependent tests | describe.serial       |
| Small data      | Array loop            |
| Large data      | JSON import           |
| Maintainability | JSON + import         |
| Speed           | Avoid fs.readFileSync |

---

## 8Ô∏è‚É£ Interview-Ready One-Liners

- **beforeAll** runs once per file
- **beforeEach** runs before every test
- **serial** stops execution on failure
- **JSON import** is best for data-driven testing
- **Avoid fs** unless dynamic runtime data is required

---

## ‚úÖ Final Recommendation

üëâ Use **describe + hooks + JSON import** for enterprise-grade Playwright frameworks.
üëâ This structure is **scalable, readable, fast, and interview-safe**.


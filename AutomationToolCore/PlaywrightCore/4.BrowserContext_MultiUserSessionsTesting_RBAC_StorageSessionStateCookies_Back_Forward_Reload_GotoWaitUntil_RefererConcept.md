# What covered in notes

- Multiple Browser Contexts
- StorageSessionStateCookie
- Back_Forward_Reloa
- GotoWaitUntil for URL load
- RefererConcept


## Why we learn?

- Multiple Browser Contexts – To test multiple users simultaneously with completely isolated sessions, just like real production users.
- Storage Session State (Cookies/Tokens) – To skip repeated logins and make automation faster, stable, and CI-friendly.
- Back / Forward / Reload – To validate real user browser navigation and ensure the application handles history and refresh correctly.
- goto + waitUntil – To control page load timing and prevent flaky tests in modern, API-driven applications.
- Referer Concept – To verify request source, security rules, and partner/payment gateway integrations.

## 1. Multiple Browser Contexts (Parallel Login Sessions)

### Code

```ts
import test, { Browser, BrowserContext, chromium, Page } from '@playwright/test';

test('browser context test', async () => {
  const browser: Browser = await chromium.launch();

  const context1: BrowserContext = await browser.newContext();
  const context2: BrowserContext = await browser.newContext();

  const page1: Page = await context1.newPage();
  const page2: Page = await context2.newPage();

  await page1.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await page1.fill('#input-email', 'user1@gmail.com');
  await page1.fill('#input-password', 'password1');
  await page1.click("//input[@value='Login']");

  await page2.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await page2.fill('#input-email', 'user2@gmail.com');
  await page2.fill('#input-password', 'password2');
  await page2.click("//input[@value='Login']");
});
```

### Output

- Two independent login sessions
- No shared cookies or storage

### Use Cases

- Multi-user testing
- Admin vs customer scenarios
- Chat and collaboration apps

### Best Practices

- Use separate browser contexts for isolation
- Do not use multiple pages for different users

---

## 2. Save Login Session (Storage State)

### locally for specific test files

### Code

```ts
import { test } from '@playwright/test';

test('save login session', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await page.fill('#input-email', 'user@gmail.com');
  await page.fill('#input-password', 'password');
  await page.click("//input[@type='submit']");

  await page.context().storageState({ path: 'auth/session.json' });
});
```

### Output

- `session.json` file generated
- Cookies and localStorage saved

### Use Cases

- Skip repetitive login
- Speed up regression execution

### Best Practices

- Generate once using setup project
- Never commit session files

---

### Global Session Reuse (playwright.config.ts) (Not recommanded)

### Code
 
```ts
use: {
  headless: false,
  trace: 'retain-on-failure',
  storageState: 'auth/session.json'
}
```

### Output

- All tests start in logged-in state

### Use Cases

- CI/CD pipelines
- Large regression suites

### Best Practices

- Use only when role is common
- Refresh session periodically

---

###  Per-Test Session Reuse

### Code

```ts
import { test } from '@playwright/test';

test.use({ storageState: 'auth/session.json' });

test('open cart without login', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=checkout/cart');
});
```

### Output

- User directly accesses secured page

### Use Cases

- Role-based testing
- Parallel flows

### Best Practices

- Prefer per-test usage for multi-role apps

---

###  Scenarios Not Supported by Storage State

- OTP-based authentication
- OAuth 2.0
- MFA / 2FA
- CAPTCHA

### Reason

- Requires real-time server-side validation

## 3. Browser Navigation (Back / Forward / Reload)

### Code

```ts
import { test } from '@playwright/test';

test('navigation test', async ({ page }) => {
  await page.goto('https://playwright.dev');
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await page.goBack();
  await page.goForward();
  await page.reload();
});
```

### Output

- Browser navigation simulated

### Use Cases

- SPA navigation testing
- History validation

### Best Practices

- Always assert URL or page state

---

## 3. Wait Strategies (`goto + waitUntil`)

Playwright waits for page loading based on specific lifecycle events. Choosing the correct option is critical to avoid flaky tests.

---

### Available `waitUntil` Options

| Option | Meaning | When It Triggers |
|------|--------|-----------------|
| `load` | Default behavior | Page load event fired (HTML + subresources) |
| `domcontentloaded` | DOM ready | HTML parsed, JS may still load |
| `networkidle` | Network idle | No network requests for 500 ms |
| `commit` | Navigation started | First response received |

---

### Code Example

```ts
import { test } from '@playwright/test';

test('wait strategies example', async ({ page }) => {
  await page.goto('https://www.amazon.com', { waitUntil: 'load' });
});
```

---

### Output / Behavior

- Playwright waits until the selected lifecycle event completes
- Test execution continues only after page readiness

---

### When to Use Each Option

#### `load` (Default – Recommended)

**Use When:**
- Normal web applications
- E-commerce websites
- Login and form-based flows

**Why:**
- Balanced and stable
- Waits for most resources

---

#### `domcontentloaded`

**Use When:**
- SPA frameworks (React, Angular, Vue)
- When UI renders before API data

**Why:**
- Faster execution
- DOM elements are available early

---

#### `networkidle`

**Use When:**
- Dashboard pages
- Analytics-heavy applications
- Pages loading data from multiple APIs

**Why:**
- Ensures all background API calls finish

⚠️ **Caution:**
- Can cause flakiness if APIs poll continuously

---

#### `commit`

**Use When:**
- Navigation verification
- Redirect validation
- URL change assertions

**Why:**
- Fastest
- Does not wait for page rendering

---

### Best Practices for Wait Strategies

- Prefer default `load` unless there is a strong reason
- Avoid `networkidle` for real-time or polling apps
- Never combine `waitForTimeout` with `waitUntil`
- Always wait for **elements**, not pages, when possible

---

## 4. Referer Header Validation

The **Referer header** tells the server where the request originated from. Many systems rely on this for security and authorization.

---

### Code Example

```ts
import { test } from '@playwright/test';

test('referer validation', async ({ page }) => {
  await page.goto('https://www.amazon.com', { referer: 'http://www.abc.com' });
});
```

---

### Output / Behavior

- Server receives request with `Referer: http://www.abc.com`
- Application may allow or block access based on source

---

### Real-World Use Cases

#### Payment Gateway Testing

- Validate redirection from merchant site to payment gateway
- Ensure gateway rejects unknown sources

#### Partner Integration Flows

- Partner A → Partner B navigation
- Verify allowed domains

#### Security & Compliance Testing

- Anti-hotlinking validation
- CSRF protection checks
- Header-based access rules

---

### When Referer Is Mandatory

- Banking applications
- Payment portals
- B2B partner systems

---

### Best Practices for Referer Testing

- Always validate backend response (403 / 401 / success)
- Combine with request interception for deeper checks
- Do not rely only on UI-level success

---

## Architect Summary

- **WaitUntil** controls *when* your test proceeds
- **Referer** controls *where* your request is allowed from
- Both are critical for **stable automation and secure system validation**

---


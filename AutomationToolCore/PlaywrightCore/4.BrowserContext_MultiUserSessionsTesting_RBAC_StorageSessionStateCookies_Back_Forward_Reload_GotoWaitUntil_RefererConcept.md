# What covered in notes

- Multiple Browser Contexts
- StorageSessionStateCookie
- Back_Forward_Reloa
- GotoWaitUntil for URL load
- RefererConcept


## Why we learn?

- Multiple Browser Contexts – To test multiple users simultaneously with completely isolated sessions, just like real production users.
- Storage Session State (Cookies/Tokens) – To skip repeated logins and make automation faster, stable, and CI-friendly.
- Back / Forward / Reload – To validate real user browser navigation and ensure the application handles history and refresh correctly.
- goto + waitUntil – To control page load timing and prevent flaky tests in modern, API-driven applications.
- Referer Concept – To verify request source, security rules, and partner/payment gateway integrations.

## 1. Multiple Browser Contexts (Parallel Login Sessions)

### Code

```ts
import test, { Browser, BrowserContext, chromium, Page } from '@playwright/test';

test('browser context test', async () => {
  const browser: Browser = await chromium.launch();

  const context1: BrowserContext = await browser.newContext();
  const context2: BrowserContext = await browser.newContext();

  const page1: Page = await context1.newPage();
  const page2: Page = await context2.newPage();

  await page1.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await page1.fill('#input-email', 'user1@gmail.com');
  await page1.fill('#input-password', 'password1');
  await page1.click("//input[@value='Login']");

  await page2.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await page2.fill('#input-email', 'user2@gmail.com');
  await page2.fill('#input-password', 'password2');
  await page2.click("//input[@value='Login']");
});
```

### Output

- Two independent login sessions
- No shared cookies or storage

### Use Cases

- Multi-user testing
- Admin vs customer scenarios
- Chat and collaboration apps

### Best Practices

- Use separate browser contexts for isolation
- Do not use multiple pages for different users

---

## 2. Save Login Session (Storage State)

### Code

```ts
import { test } from '@playwright/test';

test('save login session', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await page.fill('#input-email', 'user@gmail.com');
  await page.fill('#input-password', 'password');
  await page.click("//input[@type='submit']");

  await page.context().storageState({ path: 'auth/session.json' });
});
```

### Output

- `session.json` file generated
- Cookies and localStorage saved

### Use Cases

- Skip repetitive login
- Speed up regression execution

### Best Practices

- Generate once using setup project
- Never commit session files

---

## 3. Global Session Reuse (playwright.config.ts)

### Code

```ts
use: {
  headless: false,
  trace: 'retain-on-failure',
  storageState: 'auth/session.json'
}
```

### Output

- All tests start in logged-in state

### Use Cases

- CI/CD pipelines
- Large regression suites

### Best Practices

- Use only when role is common
- Refresh session periodically

---

## 4. Per-Test Session Reuse

### Code

```ts
import { test } from '@playwright/test';

test.use({ storageState: 'auth/session.json' });

test('open cart without login', async ({ page }) => {
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=checkout/cart');
});
```

### Output

- User directly accesses secured page

### Use Cases

- Role-based testing
- Parallel flows

### Best Practices

- Prefer per-test usage for multi-role apps

---

## 5. Browser Navigation (Back / Forward / Reload)

### Code

```ts
import { test } from '@playwright/test';

test('navigation test', async ({ page }) => {
  await page.goto('https://playwright.dev');
  await page.goto('https://naveenautomationlabs.com/opencart/index.php?route=account/login');
  await page.goBack();
  await page.goForward();
  await page.reload();
});
```

### Output

- Browser navigation simulated

### Use Cases

- SPA navigation testing
- History validation

### Best Practices

- Always assert URL or page state

---

## 6. Wait Strategies

### Code

```ts
import { test } from '@playwright/test';

test('wait strategies', async ({ page }) => {
  await page.goto('https://www.amazon.com', { waitUntil: 'load' });
});
```

### Output

- Page waits until specified load event

### Use Cases

- Heavy SPA apps
- API-dependent pages

### Best Practices

- Prefer default `load`
- Avoid `networkidle` unless required

---

## 7. Referer Header Validation

### Code

```ts
import { test } from '@playwright/test';

test('referer validation', async ({ page }) => {
  await page.goto('https://www.amazon.com', { referer: 'http://www.abc.com' });
});
```

### Output

- Target application receives source URL

### Use Cases

- Payment gateway testing
- Partner flow validation
- Security header checks

### Best Practices

- Validate backend authorization

---

## 8. Scenarios Not Supported by Storage State

### Not Supported

- OTP-based authentication
- OAuth 2.0
- MFA / 2FA
- CAPTCHA

### Reason

- Requires real-time server-side validation
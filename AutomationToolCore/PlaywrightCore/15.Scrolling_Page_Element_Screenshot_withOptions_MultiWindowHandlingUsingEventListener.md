# What covered in notes
- Scrolling
- Screenshort and its options
- MutiwindowHandle using waitforevent

## 1. Page Scrolling Techniques

### 1.1 Normal Scroll using JavaScript

**Concept**  
Manually scroll the page using browser JavaScript APIs.

**When to use**  
- Simple static pages
- When Playwright auto-scroll doesn’t trigger

**Code**
```ts
await page.evaluate(() => window.scrollBy(0, 1000));
await page.waitForTimeout(2000);
```

**Output**  
Page scrolls down by 1000px.

**Notes**  
- Fast but not user-like
- May fail for lazy loading websites

---

### 1.2 Scroll to Bottom / Top

**Code**
```ts
await page.evaluate(() => window.scrollTo(0, document.body.scrollHeight));
await page.waitForTimeout(2000);

await page.evaluate(() => window.scrollTo(0, 0));
```

**Use case**  
- Reach footer
- Reset page scroll

---

### 1.3 Scroll Element into View (BEST PRACTICE)

**Concept**  
Scroll only until a particular element becomes visible.

**Code**
```ts
const career = page.locator("a[href*='company/careers'][target='_blank']");
await career.scrollIntoViewIfNeeded();
await career.click();
```

**Why best**  
- Safe
- No hardcoded scroll values
- Playwright-managed

---

## 2. Lazy Loading Scroll (Amazon / Infinite Scroll)

### Concept
Content loads **only when user scrolls**.

**Correct Pattern**
```ts
const section = page.getByText('Inspired by your browsing history');

while (!await section.isVisible()) {
  await page.mouse.wheel(0, 500);
  await page.waitForTimeout(2000);
}

console.log(await section.textContent());
```

**Output**  
Section text prints once it appears.

**Important Notes**  
- Use `mouse.wheel()` for user‑like scrolling
- Avoid `scrollTo(bottom)` for lazy sites

---

## 3. Screenshot Handling (Page & Element)

### 3.1 Full Page & Viewport Screenshot

**Code**
```ts
await page.screenshot({ path: 'one.png' });
await page.screenshot({ path: 'full.png', fullPage: true });
```

**Output**  
PNG images saved to project folder.

---

### 3.2 Screenshot with Clip Area

```ts
await page.screenshot({
  path: 'clip.png',
  clip: { x: 0, y: 0, width: 800, height: 600 }
});
```

---

### 3.3 Element Screenshot

```ts
const logo = page.locator('img[alt="OrangeHRM Logo"]').first();
await logo.screenshot({ path: 'logo.png' });
```

---

### 3.4 JPEG & Quality Control

```ts
await page.screenshot({
  path: 'page.jpg',
  type: 'jpeg',
  quality: 30
});
```

---

### 3.5 Screenshot as Buffer

```ts
const buffer = await page.screenshot();
console.log(buffer.length);
```

**Use case**  
- Attach to report
- Upload to server

---

## 4. Multi‑Window / Popup Handling (Event Listener)

### Concept
New tab opens → Playwright treats it as **popup event**.

###  special note:
- dont use await in Promise.all - because if any of the promises is fulfilled, it will be retunred immedialtely.
- Dont change the sequence also - first wait for the event, then trigger the event by clicking on it.
- dont use await page.locator().click() then await page.waitForEvent() - it will be running in the sequential mode.
- after click() - promise is fulfilled and it will be returned - it wont capture the event.
- so always use without await here with the same sequence:1st wait for the popup event. 2nd perform click on the element.
- Here [nePage] is array distructuring. because promise.all return all. first waitforevent return page and second retun void as click.
-  we skip void and only use page things so we written [newPage[] as array distructring and return array.

```ts
const [newPage] = await Promise.all([
  page.waitForEvent('popup'),
  page.locator("//a[contains(@href,'linkedin')]").click()
]);

console.log(await newPage.title());
console.log(newPage.url());
await newPage.close();
```

**Why Promise.all?**  
- Prevents race condition
- Listener starts BEFORE click

**Notes**  
- `[newPage]` = array destructuring
- `click()` returns Promise<void>

---

### Bring Parent Page Back

```ts
await page.bringToFront();
console.log(await page.title());
```

---

## 5. Dialog / Alert Handling

### 5.1 Default Playwright Behavior

**Fact**  
If you DO NOTHING → Playwright auto‑dismisses alerts.

---

### 5.2 Custom Dialog Handler

```ts
page.on('dialog', async (dialog: Dialog) => {
  console.log(dialog.message());
  await dialog.accept();
});
```

**Use when**  
- Need to validate alert text
- Need to accept / dismiss manually

---

### 5.3 Remove Custom Handler (Back to Default)

```ts
page.off('dialog', handler);
```

**Result**  
Playwright resumes auto‑dismiss behavior.

---

## 6. Cookie Popup Handling using Event Listener

```ts
page.on('framenavigated', async () => {
  await page.getByText('Allow all').click();
});
```

**Use case**  
- Cookie banners
- GDPR popups

**Note**  
Avoid heavy logic inside listeners.

---

## 7. Best Practice Summary (For Students)

- Prefer `scrollIntoViewIfNeeded()` over JS scroll
- Lazy loading ≠ normal scrolling
- Always listen before triggering popup
- Promise.all returns ARRAY
- Alerts auto‑dismiss unless handled
- Element screenshots > full page when validating UI

---

## 8. Interview Ready One‑Liners

- Lazy loading works only when you trigger the correct scroll mechanism
- Promise.all prevents missing popup events
- Playwright auto‑dismisses dialogs by default
- Element scrolling is safer than page scrolling

---

## End of Canvas


# ğŸ¯ Playwright Advanced UI Canvas

This canvas covers **real-world advanced UI automation** scenarios that are commonly confusing but critical at senior / architect level.

Covered topics:
- SVG elements
- SVG inside iframe
- Shadow DOM & iframe + Shadow DOM
- Pseudo elements (`::before / ::after`)
- Reading element background & text color

Each section includes **code, output, use case, and best practices**.

---

## 1ï¸âƒ£ SVG Element (Normal Page)

### Scenario
Click the **search SVG icon** on Flipkart.

### Code
```ts
await page.goto('https://www.flipkart.com/');
await page.locator('input[name="q"]').first().fill('Macbook');

 //css
  //  await page.locator(`button[title='Search for Products, Brands and More'] svg`).click();

// XPath with SVG namespace
await page.locator(
  "(//*[name()='svg' and @fill='none']//*[name()='path'])[1]"
).click();
```

### Output
- Search is triggered
- Results page opens

### Use Case
- SVG icons (search, close, menu)
- Charts & graphs
- Maps

### Best Practices
- Prefer **parent HTML element** if clickable
- Use `name()` or `local-name()` for SVG XPath
- Avoid index-based SVG paths if possible

---

## 2ï¸âƒ£ SVG Element Inside Iframe (Map / Graph)

### Scenario
Interact with **SVG map regions** inside an iframe.

### Code
```ts
const frame = page.frameLocator("iframe[id*='map-instance']");

const regions = await frame.locator(
  "//*[local-name()='svg' and @id='map-svg']//*[local-name()='g' and @class='region']"
).all();

for (const region of regions) {
  const box = await region.boundingBox();
   console.log(box);
        //box print

        //   x: 801.5535125732422,
        //   y: 818.4965209960938,
        //   width: 62.21966552734375,
        //   height: 100.30459594726562

        //x-> left side  -box.x + box.width / 2 here left x come at center as divide width
        //y-> top side - box.y + box.height / 2 here top y come at center as divide hight

  if (!box) continue;

  await page.mouse.click(
    box.x + box.width / 2,
    box.y + box.height / 2
  );

  const state = await region.getAttribute('id');
  console.log(state);
}
```

### Output
```text
Total number of regions: 50
Texas
California
Florida
```

### Use Case
- SVG maps
- Heat maps
- Interactive charts

### Best Practices
- Tooltips may NOT exist â†’ validate **color or legend** instead
- Use `boundingBox()` for precise interaction
- Prefer API + UI validation for maps

---

## 3ï¸âƒ£ Shadow DOM Element (Normal Page)

### Scenario
Element exists **inside Shadow DOM**.

### Code
```ts
await page.goto('https://selectorshub.com/iframe-in-shadow-dom/');
await page.locator('#pizza').fill('Veg Pizza');
```

### Output
- Input value entered

### Use Case
- Web components
- Modern frontend frameworks

### Best Practices
- Playwright automatically pierces open Shadow DOM
- Avoid XPath for shadow elements

---

## 4ï¸âƒ£ Iframe + Shadow DOM (Nested)

### Scenario
Page â†’ iframe â†’ shadow DOM â†’ input

### Code
```ts
await page.goto('https://selectorshub.com/shadow-dom-in-iframe/');

await page
  .frameLocator('#pact')
  .first()
  .locator('#tea')
  .fill('Masala Tea');
```

### Output
- Input filled inside nested shadow DOM

### Use Case
- Embedded widgets
- Third-party integrations

### Best Practices
- `frameLocator()` accepts **CSS only**
- Inside frame â†’ all locators allowed
- `nth()` / `first()` acceptable if frames are identical

---

## 5ï¸âƒ£ Pseudo Elements (`::before / ::after`)

### What are Pseudo Elements?
- `::before` and `::after` are **not real HTML elements**
- They:
  - Do NOT exist in DOM
  - Cannot be located using XPath / CSS selectors
  - Are accessible only via **CSS computed styles**

### Why automation needs special handling?
- Mandatory `*` indicators
- Icons before labels
- Validation markers
- UI hints created using CSS

ğŸ‘‰ **Playwright cannot locate them directly** â†’ we must read **computed styles**.

---

## 2ï¸âƒ£ Approach 1 â€“ Using `locator.evaluate()` (Recommended)

### Concept
- Execute JavaScript **on the matched element**
- Access browser-side APIs like `getComputedStyle`
- Clean, scoped, and reliable

### Code â€“ Read `::before` content
```ts
let firstName = page.locator('label[for="input-firstname"]');

let content = await firstName.evaluate(el =>
  getComputedStyle(el, '::before').content
);
console.log(content);
```

### Output
```text
"*"
```

### Mandatory Field Check
```ts
if (content.includes('*')) {
  console.log('its mandatory field');
}
```

### Output
```text
its mandatory field
```

### Use Cases
- Mandatory field validation
- Required symbol verification
- UI regression testing
- Accessibility checks

---

## 3ï¸âƒ£ Approach 2 â€“ Using `page.evaluate()` (Alternative)

### Concept
- Execute JavaScript **globally in page context**
- Useful when locator is unavailable
- Less scoped than `locator.evaluate()`

### Code
```ts
let content = await page.evaluate(() => {
  return window.getComputedStyle(
    document.querySelector('label[for="input-firstname"]')!,
    '::before'
  ).getPropertyValue('content');
});

console.log(content);
```

### Output
```text
"*"
```

### When to Use
- Dynamic locators
- One-time validations
- Legacy scripts

âš ï¸ **Avoid for large test suites** (less maintainable)

---

## 4ï¸âƒ£ Reading CSS Properties from Pseudo Elements

### Example â€“ Color of `::before`

#### Approach 1 â€“ Locator Based
```ts
let color = await firstName.evaluate(el =>
  getComputedStyle(el, '::before').color
);
console.log(color);
```

### Output
```text
rgb(255, 0, 0)
```

#### Approach 2 â€“ Page Evaluate
```ts
let color = await page.evaluate(() => {
  return window.getComputedStyle(
    document.querySelector('label[for="input-firstname"]')!,
    '::before'
  ).getPropertyValue('color');
});

console.log(color);
```

### Use Cases
- Error indicator color validation
- UI theme consistency
- Brand guideline checks

---

## 5ï¸âƒ£ Validating Normal Element Styles (No Pseudo Elements)

### Example â€“ Button Color Validation

### Website
`https://www.orangehrm.com/en/contact-sales/`

### Code
```ts
let contactsales = page.getByRole('button', { name: 'Contact Sales' });

let backgroundColor = await contactsales.evaluate(ele =>
  getComputedStyle(ele).backgroundColor
);
console.log(backgroundColor);

let color = await contactsales.evaluate(ele =>
  getComputedStyle(ele).color
);
console.log(color);
```

### Output
```text
rgb(255, 123, 0)
rgb(255, 255, 255)
```

### Use Cases
- Button color regression
- Dark/light theme testing
- Branding verification

---

## 6ï¸âƒ£ Handling Alerts Using Page Context

### Code
```ts
await page.evaluate(() => alert('hitesh darji'));
```

### Output (Browser Alert)
```text
Alert popup displayed with message: hitesh darji
```

### Use Cases
- Demo testing
- Debugging UI flows
- Alert handling practice

---

## 7ï¸âƒ£ Best Practices (Interview + Real Project)

- Prefer `locator.evaluate()` over `page.evaluate()`
- Always validate **content + color** for pseudo elements
- Never rely on XPath for `::before / ::after`
- Add UI style checks in **smoke or visual suites**

---

## 8ï¸âƒ£ Interview One-Liner

> â€œPseudo elements donâ€™t exist in the DOM, so in Playwright we validate them using `getComputedStyle` via `evaluate()` instead of locators.â€

---

## 9ï¸âƒ£ Comparison Table â€“ All Approaches

| Aspect | locator.evaluate() | page.evaluate() |
|------|-------------------|----------------|
| Scope | Element-specific | Global page context |
| Readability | High | Medium |
| Maintainability | High | Lowâ€“Medium |
| Safe for large suites | âœ… Yes | âš ï¸ Limited |
| Best for pseudo-elements | âœ… Recommended | âš ï¸ Alternative |
| Uses Playwright Locator | âœ… Yes | âŒ No |
| Risk of null selector | âŒ Very low | âš ï¸ High |

---

## ğŸ”Ÿ Best Practices (Production + Interview)

### âœ… Always Follow
- Prefer `locator.evaluate()` over `page.evaluate()`
- Validate both **content** and **style** for pseudo elements
- Reuse locator variables instead of inline selectors
- Keep UI-style checks in **smoke or regression suites**

### âŒ Avoid
- XPath or CSS selectors for `::before / ::after`
- Hardcoding colors without brand reference
- Using `page.evaluate()` repeatedly in large test suites

### â­ Architect-Level Tips
- Combine pseudo-element checks with form validation tests
- Add style assertions only where business-critical
- Document UI assumptions in test names

---

## 1ï¸âƒ£1ï¸âƒ£ When This Skill Matters Most

- E-commerce checkout forms
- Banking & finance portals
- Government applications
- Design-systemâ€“driven products
- Accessibility & compliance testing

---

## 1ï¸âƒ£2ï¸âƒ£ Interview Power Line

> â€œPseudo elements are not part of the DOM, so in Playwright we validate them using `getComputedStyle` via `locator.evaluate()` instead of locators or XPath.â€


---

## ğŸ† Global Best Practices (SAVE THIS)

- SVG â†’ Use XPath `name()` and `local-name()` only when required
- Prefer HTML wrappers around SVG (ask devs)
- `frameLocator()` â†’ CSS only for iframe
- Shadow DOM â†’ Playwright handles automatically
- Use `evaluate()` as **escape hatch**, not default
- If UI data not visible â†’ validate API or CSS state

---

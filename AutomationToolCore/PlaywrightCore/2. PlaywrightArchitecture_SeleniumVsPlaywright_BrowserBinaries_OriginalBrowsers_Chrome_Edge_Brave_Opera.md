# What covered in notes

- Plywright Architecture
- Channel and Executable Path of browsers
- Selenium vs playwright


## Why we learn?

- Plywright Architecture- To understand how Playwright controls browsers reliably and handles modern web apps better than traditional tools.
- Channel and Executable Path of browsers- To run tests on exact real browser versions (Chrome, Edge, system-installed) and avoid environment issues.
- Selenium vs playwright- To know why Playwright is faster, more stable, and better suited for modern SPA and AI-driven testing than Selenium.


## 1. Selenium WebDriver Architecture

**Flow:**
Test Script → Client Library (Java/Python/JS) → W3C WebDriver Protocol → Browser Driver → Browser

**Key Characteristics:**

- Communication happens over **HTTP (request/response)**
- Each command is a separate HTTP call
- Browser drivers (ChromeDriver, GeckoDriver, EdgeDriver) act as middlemen
- Slower execution due to stateless HTTP calls
- More flaky in modern SPA and dynamic applications

![alt text](selenium-webdriver-architecture.png)

---

## 2. Playwright Architecture

**Flow:**
Test Script → Playwright Client → Playwright Driver (Node.js) → Browser Engine

**Key Characteristics:**

- Uses **WebSocket (bi-directional, persistent connection)**
- One connection reused for all commands
- Faster and more stable execution
- Direct control over browser engines
- Better handling of modern web apps (React, Angular, Vue)

![alt text](Playwright_Arch.png)

---

## 3. HTTP vs WebSocket (Core Difference)

### Selenium (HTTP)

- Request → Response → Connection closed
- New connection for every command
- Higher latency

### Playwright (WebSocket)

- One persistent connection
- Commands sent continuously
- Low latency and real-time control
![alt text](http-vs-websocket.png)

![alt text](Sel-vs-Pw.png)

---

## 4. Browser Control Comparison

### Selenium

- Relies on external browser drivers
- Browser vendors maintain drivers
- Limited deep browser control

### Playwright

- Uses patched/custom browser binaries
- Direct CDP (Chrome DevTools Protocol) usage
- Deep control over network, frames, events

---

## 5. Stability & Speed Comparison

| Aspect        | Selenium | Playwright |
| ------------- | -------- | ---------- |
| Communication | HTTP     | WebSocket  |
| Speed         | Slower   | Faster     |
| Flakiness     | Higher   | Lower      |
| SPA Support   | Moderate | Excellent  |
| Auto-waits    | Limited  | Built-in   |

---

## 6. Interview One-Liner

> Selenium uses stateless HTTP communication via browser drivers, whereas Playwright uses a persistent WebSocket connection with direct browser control, making it faster and more reliable for modern applications.

---

## 7. RPA Perspective (How Playwright fits RPA)

**Important clarification (conceptual correction):**

RPA at architecture level works like **RPC (Remote Procedure Call)**.

In **Playwright**, automation commands behave exactly like RPC calls:

- Method calls (page.click, page.goto)
- Serialized into **JSON**
- Sent over a **persistent WebSocket connection**
- Executed remotely by the browser engine

So technically:
> **Playwright = RPC-style browser automation over WebSocket**

This is why Playwright naturally fits **modern RPA and AI-agent execution**.

---

## 8. JSON Messaging & Command Flow (Important)

Playwright communication is **NOT REST API based**.

### How commands flow internally:

1. Test code sends a command (e.g., page.goto)
2. Command is converted to **JSON message**
3. JSON is sent over **WebSocket** to Playwright Node.js driver
4. Driver translates JSON into browser-specific protocol
5. Browser executes action and sends response back

Example (conceptual JSON):

```json
{
  "id": 1,
  "method": "page.goto",
  "params": {
    "url": "https://example.com"
  }
}
```

This makes Playwright:

- Fast
- Stateful
- Real-time

---

## 9. Node.js Backend – Central Brain

Playwright uses a **Node.js server (driver)** as a middle layer.

Responsibilities of Node.js driver:

- Maintains persistent WebSocket connection
- Manages browser lifecycle
- Routes commands to correct browser engine
- Handles retries, waits, and events

Think of it as:
> **Node.js = Control Tower**

---

## 10. How Playwright Talks to Different Browsers

### Chromium-based (Chrome, Edge, Brave, Opera)

- Uses **Chrome DevTools Protocol (CDP)**
- Same core engine, different channels

### Firefox

- Uses **custom Playwright protocol**
- Patched Firefox binary maintained by Playwright

### Safari

- Uses **WebKit custom Playwright build**
- No external driver required

---

## 11. Browser Binaries & Executable Path

Playwright **downloads and manages its own browser binaries** automatically.

### Where binaries are stored

- Stored locally in **ms-playwright cache**
- OS-specific paths

**Examples:**

- macOS: `~/Library/Caches/ms-playwright/`
- Windows: `C:\Users\<user>\AppData\Local\ms-playwright\`
- Linux: `~/.cache/ms-playwright/`

### Key properties

- Same browser versions across all machines
- Independent of system-installed browsers
- Used in local, CI, and cloud environments

### Benefits

- No browser version mismatch
- High CI stability
- Fully reproducible test runs

---

## 2. Channel vs Executable Path (Very Important)

### Channel

- Used when browser is **Chromium-based**
- Playwright internally maps channel → browser
- Cleaner and recommended approach

### Executable Path

- Used when browser is **not officially bundled**
- You explicitly point to browser binary
- Required for custom or third-party browsers

---

## 3. Channel Usage (Chrome & Edge)

### Supported via channel

- Google Chrome
- Microsoft Edge

### Example: Chrome with channel

```ts
import { chromium } from '@playwright/test';

const browser = await chromium.launch({
  channel: 'chrome',
  headless: false
});
```

### Example: Edge (channel)

```ts
const browser = await chromium.launch({
  channel: 'msedge',
  headless: false
});
```

Why channel works here:

- Chrome & Edge are Chromium-based
- Playwright knows their internal structure

---

## 4. Executable Path Usage (Opera & Brave)

Opera and Brave are **Chromium-based but not officially bundled**.

So we use **executablePath**.

### Example: Brave with executablePath

```ts
const browser = await chromium.launch({
  executablePath: '/Applications/Brave Browser.app/Contents/MacOS/Brave Browser',
  headless: false
});
```

### Example: Opera

```ts
const browser = await chromium.launch({
  executablePath: '/Applications/Opera.app/Contents/MacOS/Opera',
  headless: false
});
```

Windows paths example:

```ts
executablePath: 'C:\\Program Files\\BraveSoftware\\Brave-Browser\\Application\\brave.exe'
```

---

## 5. Firefox Nightly (Playwright Custom Build)

Playwright does **not rely on system Firefox**.

- Uses **patched Firefox Nightly build**
- Maintained and versioned by Playwright team

### Example: Firefox Nightly

```ts
import { firefox } from '@playwright/test';

const browser = await firefox.launch({
  headless: false
});
```

Why Nightly:

- Needed for deep browser instrumentation
- Enables stable automation APIs

---

## 6. Safari / WebKit Handling

Playwright uses **WebKit custom build**.

Important notes:

- Not system Safari
- Closest representation of Safari engine
- Updates come via Playwright releases

### Example

```ts
import { webkit } from '@playwright/test';

const browser = await webkit.launch({
  headless: false
});
```

Safari updates depend on:

- Playwright WebKit build updates
- Not OS Safari updates

---

## 7. When to Use What (Summary Table)

| Browser | Method         | Reason                    |
| ------- | -------------- | ------------------------- |
| Chrome  | channel        | Official Chromium support |
| Edge    | channel        | Official Chromium support |
| Brave   | executablePath | Third-party Chromium      |
| Opera   | executablePath | Third-party Chromium      |
| Firefox | Built-in       | Custom patched Nightly    |
| Safari  | Built-in       | Custom WebKit build       |

---

## 8. Interview-Ready One-Liner

> Playwright manages its own browser binaries for consistency; channels are used for officially supported Chromium browsers like Chrome and Edge, while executablePath is required for third-party browsers like Brave and Opera, with Firefox and Safari handled via Playwright’s custom builds.

---

## 12. Selenium vs Playwright – Deep Reason (Architecture)

| Aspect        | Selenium         | Playwright           |
| ------------- | ---------------- | -------------------- |
| Protocol      | HTTP (stateless) | WebSocket (stateful) |
| Middle Layer  | Browser Driver   | Node.js Driver       |
| Command Type  | REST calls       | JSON over WebSocket  |
| Connection    | Per command      | Persistent           |
| RPA Readiness | Low              | High                 |

---